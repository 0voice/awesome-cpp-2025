# 基础语法篇
## 一、变量与数据类型
### 1. 基本数据类型
C++ 中的基础数据类型分为四大类，核心用于存储不同类型的数据，适配不同场景：
| 类型分类 | 具体类型 | 说明 | 示例 |
|----------|----------|------|------|
| 整型     | `int`    | 基本整数类型（通常4字节） | `int age = 25;` |
|          | `short`  | 短整型（2字节，范围更小） | `short score = 95;` |
|          | `long`   | 长整型（4/8字节，视系统而定） | `long population = 1000000L;` |
|          | `long long` | 超长整型（8字节，支持更大数值） | `long long bigNum = 12345678901234LL;` |
|          | 无符号整型 | `unsigned int`（仅存非负数，范围翻倍） | `unsigned int count = 100;` |
| 浮点型   | `float`  | 单精度浮点型（4字节，精度较低） | `float pi = 3.14f;`（必须加`f`，否则默认`double`） |
|          | `double` | 双精度浮点型（8字节，推荐优先使用） | `double salary = 12345.67;` |
| 字符型   | `char`   | 存储单个字符（1字节，本质是ASCII码值） | `char ch = 'A';`（单引号包裹） |
|          | `wchar_t`| 宽字符型（支持中文等多字节字符） | `wchar_t wch = L'中';`（加`L`前缀） |
| 布尔型   | `bool`   | 仅存`true`（1）或`false`（0） | `bool isPass = true;` |

### 2. 常量修饰符 `const`
- **作用**：定义不可修改的常量（只读变量），编译期检查，避免误修改。
- **核心特点**：
  1. 必须初始化，且初始化后不能赋值修改；
  2. 局部`const`存储在栈上，全局`const`存储在只读数据区（修改会崩溃）。
- **示例**：
  ```cpp
  const int MAX_AGE = 100; // 常量，不可修改
  // MAX_AGE = 200; // 编译错误：只读变量不能赋值
  const double PI = 3.1415926;
  ```

### 3. 类型别名 `typedef`
- **作用**：给已有数据类型起别名，简化复杂类型书写（如指针、结构体类型）。
- **语法**：`typedef 原类型 别名;`
- **示例**：
  ```cpp
  typedef int Score; // 给int起别名Score
  Score math = 90; // 等价于 int math = 90;

  typedef char* String; // 给字符指针起别名String（C风格字符串常用）
  String name = "Tom"; // 等价于 char* name = "Tom";
  ```
- **注意**：C++11后推荐用`using`替代`typedef`（语法更清晰，支持模板别名），但`typedef`仍是基础考点。

## 二、运算符与表达式
### 1. 算术运算符
用于数值计算，注意整数除法和取模的特性：
| 运算符 | 功能 | 示例 | 结果 |
|--------|------|------|------|
| `+` `-` | 加、减 | `5+3` `5-3` | 8、2 |
| `*` `/` | 乘、除 | `5*3` `5/3` | 15、1（整数除法：舍弃小数部分） |
| `%`     | 取模（余数） | `5%3` `7%4` | 2、3（仅支持整型） |
- **易错点**：
  - 除数不能为0（运行时崩溃）；
  - 浮点型除法需显式转换：`(double)5/3` 结果为`1.666...`。

### 2. 关系运算符
用于比较两个值的关系，返回`bool`类型（`true`/`false`）：
| 运算符 | 功能 | 示例 | 结果 |
|--------|------|------|------|
| `==` | 等于 | `5==3` | `false` |
| `!=` | 不等于 | `5!=3` | `true` |
| `>` `<` | 大于、小于 | `5>3` `5<3` | `true`、`false` |
| `>=` `<=` | 大于等于、小于等于 | `5>=5` `3<=2` | `true`、`false` |
- **面试坑**：不要把`==`写成`=`（赋值运算符），如`if (a=5)` 会将5赋值给`a`，且表达式结果为5（非0即`true`），逻辑错误。

### 3. 逻辑运算符
用于逻辑判断（与/或/非），支持**短路求值**（面试高频考点）：
| 运算符 | 功能 | 短路规则 | 示例 | 结果 |
|--------|------|----------|------|------|
| `&&` | 逻辑与（都真才真） | 左为`false`时，右表达式不执行 | `(3>5)&&(++a)` | `false`（`a`不自增） |
| `||` | 逻辑或（一真即真） | 左为`true`时，右表达式不执行 | `(3<5)||(++a)` | `true`（`a`不自增） |
| `!`  | 逻辑非（取反） | 无短路 | `!(3>5)` | `true` |

### 4. 复合赋值运算符
简化“变量 = 变量 运算符 表达式”的写法，效率略高于普通赋值：
| 运算符 | 等价写法 | 示例 | 结果 |
|--------|----------|------|------|
| `+=` | `a = a + b` | `a=2; a+=3;` | `a=5` |
| `-=` | `a = a - b` | `a=5; a-=2;` | `a=3` |
| `*=` `/=` `%=` | 同理 | `a=4; a*=2;` | `a=8` |

### 5. 自增自减运算符（前置 vs 后置）
**核心考点**：改变变量值的同时，返回值不同：
| 类型 | 语法 | 执行逻辑 | 示例 | 结果 |
|------|------|----------|------|------|
| 前置 | `++a` `--a` | 先自增/自减，再返回变量本身 | `a=2; b=++a;` | `a=3`，`b=3` |
| 后置 | `a++` `a--` | 先返回变量原值，再自增/自减 | `a=2; b=a++;` | `a=3`，`b=2` |
- **示例**：
  ```cpp
  int a = 1;
  int b = a++ + ++a; // 计算过程：1（a++返回1） + 3（++a先自增为3） → b=4
  cout << b; // 输出4
  ```

## 三、控制流
### 1. 分支结构：`if-else`
根据条件执行不同代码块，支持嵌套：
- **语法**：
  ```cpp
  if (条件1) {
    // 条件1为true时执行
  } else if (条件2) {
    // 条件1为false、条件2为true时执行
  } else {
    // 所有条件都为false时执行
  }
  ```
- **示例**：
  ```cpp
  int score = 85;
  if (score >= 90) {
    cout << "优秀" << endl;
  } else if (score >= 60) {
    cout << "及格" << endl; // 执行此分支
  } else {
    cout << "不及格" << endl;
  }
  ```
- **注意**：单语句块可省略`{}`，但推荐始终添加（避免逻辑错误）。

### 2. 分支结构：`switch`
适用于多条件等值判断（比`if-else`更简洁）：
- **语法**：
  ```cpp
  switch (表达式) { // 表达式必须是整型/字符型/枚举型
    case 常量1:
      // 执行代码
      break; // 跳出switch（必须加，否则穿透）
    case 常量2:
      // 执行代码
      break;
    default:
      // 所有case不匹配时执行（可选）
  }
  ```
- **示例**：
  ```cpp
  char grade = 'B';
  switch (grade) {
    case 'A':
      cout << "90+";
      break;
    case 'B':
      cout << "80-89"; // 执行此分支
      break;
    case 'C':
      cout << "60-79";
      break;
    default:
      cout << "不及格";
  }
  ```
- **面试考点**：`break`的作用（避免case穿透）、`default`的位置（可在任意处，无匹配时执行）。

### 3. 循环结构：`for`/`while`/`do-while`
#### （1）`for`循环（最常用，适合已知循环次数）
- **语法**：`for (初始化; 循环条件; 增量/减量) { 循环体 }`
- **示例**：遍历1~5：
  ```cpp
  for (int i = 1; i <= 5; i++) {
    cout << i << " "; // 输出：1 2 3 4 5
  }
  ```
- **灵活用法**：初始化和增量可省略（如`for (; ; )` 是死循环）。

#### （2）`while`循环（适合未知循环次数，先判断后执行）
- **语法**：`while (循环条件) { 循环体 }`
- **示例**：累加1~100：
  ```cpp
  int sum = 0, i = 1;
  while (i <= 100) {
    sum += i;
    i++;
  }
  cout << sum; // 输出5050
  ```

#### （3）`do-while`循环（先执行后判断，至少执行一次）
- **语法**：`do { 循环体 } while (循环条件);`（注意末尾分号）
- **示例**：输入密码，直到正确为止：
  ```cpp
  string pwd;
  do {
    cout << "输入密码：";
    cin >> pwd;
  } while (pwd != "123456");
  cout << "密码正确！";
  ```

### 4. 循环控制：`break`/`continue`
- `break`：跳出当前循环或`switch`语句（直接终止）；
- `continue`：跳过本次循环剩余代码，直接进入下一次循环；
- **示例**：
  ```cpp
  for (int i = 1; i <= 5; i++) {
    if (i == 3) break; // 跳出循环，后续i=4、5不执行
    cout << i << " "; // 输出：1 2
  }

  for (int i = 1; i <= 5; i++) {
    if (i == 3) continue; // 跳过i=3，直接执行i=4
    cout << i << " "; // 输出：1 2 4 5
  }
  ```

### 5. 输入输出：`cin`/`cout` + `iomanip`
#### （1）基础输入输出
- `cout`：输出（控制台打印），需包含头文件 `<iostream>`；
- `cin`：输入（读取控制台输入），支持多变量连续输入；
- **示例**：
  ```cpp
  #include <iostream>
  using namespace std; // 避免写std::cout（下文详解）

  int main() {
    int a;
    string name;
    cout << "输入姓名和年龄：";
    cin >> name >> a; // 连续输入，空格/回车分隔
    cout << "你好，" << name << "，年龄" << a << endl; // endl：换行+刷新缓冲区
    return 0;
  }
  ```

#### （2）格式控制：`iomanip` 头文件
用于控制输出格式（如保留小数、对齐、进制转换）：
| 功能 | 函数/操作符 | 示例 | 结果 |
|------|-------------|------|------|
| 保留小数 | `fixed` + `setprecision(n)` | `cout << fixed << setprecision(2) << 3.1415;` | 3.14 |
| 进制转换 | `hex`（十六进制）、`oct`（八进制）、`dec`（十进制） | `cout << hex << 255;` | ff |
| 对齐 | `setw(n)`（宽度）+ `left`（左对齐）/`right`（右对齐） | `cout << setw(5) << left << "Tom";` | Tom  （占5位，左对齐） |
- **示例**：
  ```cpp
  #include <iomanip> // 必须包含此头文件
  cout << fixed << setprecision(3) << 1.2345 << endl; // 1.235（四舍五入）
  cout << hex << uppercase << 255 << endl; // FF（大写十六进制）
  ```

### 6. 命名空间：`namespace`
- **作用**：解决命名冲突（如不同库中同名函数/变量），C++核心特性。
- **核心用法**：
  1. 定义命名空间：
     ```cpp
     namespace MySpace {
       int add(int a, int b) {
         return a + b;
       }
     }
     ```
  2. 使用命名空间：
     - 直接指定：`MySpace::add(1,2);`（最安全）；
     - `using namespace 命名空间;`：全局引入（简化书写，如`using namespace std;`）；
     - 部分引入：`using MySpace::add;`（仅引入指定成员）。
- **面试考点**：`std`是C++标准库的命名空间（所有标准库函数/类都在`std`中），不推荐在头文件中使用`using namespace std;`（可能引发命名冲突）。

## 四、函数
### 1. 函数的定义与声明
- **函数三要素**：返回值类型、函数名、参数列表；
- **声明**：告诉编译器函数的存在（无需实现），通常放在头文件（`.h`）中；
- **定义**：函数的具体实现（必须有函数体），通常放在源文件（`.cpp`）中；
- **语法**：
  ```cpp
  // 声明（头文件中）
  int add(int a, int b); // 分号结尾，无函数体

  // 定义（源文件中）
  int add(int a, int b) { // 无分号，有函数体
    return a + b; // 返回值（与返回值类型一致）
  }
  ```
- **注意**：函数声明必须与定义的“返回值类型、函数名、参数列表”完全一致（参数名可不同）。

### 2. 函数参数传递：值传递/引用传递/指针传递
#### （1）值传递（默认）
- 特点：传递参数的**副本**，函数内修改不影响原变量；
- 示例：
  ```cpp
  void swap(int x, int y) {
    int temp = x;
    x = y;
    y = temp; // 仅修改副本，原变量不变
  }
  int a=1, b=2;
  swap(a, b);
  cout << a << "," << b; // 输出1,2（原变量未交换）
  ```

#### （2）引用传递（`&`）
- 特点：传递变量的**别名**（本质是指针的语法糖），函数内修改直接影响原变量；
- 语法：参数类型后加`&`；
- 示例：
  ```cpp
  void swap(int& x, int& y) { // x是a的别名，y是b的别名
    int temp = x;
    x = y;
    y = temp; // 修改别名即修改原变量
  }
  int a=1, b=2;
  swap(a, b);
  cout << a << "," << b; // 输出2,1（原变量交换成功）
  ```
- **优势**：比指针更安全（不会出现野指针）、语法更简洁，是C++推荐的传递方式。

#### （3）指针传递（`*`）
- 特点：传递变量的**地址**，函数内通过解引用（`*`）修改原变量；
- 语法：参数类型为指针（`类型*`）；
- 示例：
  ```cpp
  void swap(int* x, int* y) { // x存储a的地址，y存储b的地址
    int temp = *x;
    *x = *y;
    *y = temp; // 解引用修改地址指向的原变量
  }
  int a=1, b=2;
  swap(&a, &b); // 传递地址（&取地址符）
  cout << a << "," << b; // 输出2,1（原变量交换成功）
  ```
- **面试考点**：引用与指针的核心区别（后续“指针入门”详细讲解）。

### 3. 返回值
- 函数可通过`return`语句返回一个值（类型与声明的返回值类型一致）；
- 无返回值时，返回值类型为`void`（可省略`return`）；
- 示例：
  ```cpp
  int max(int a, int b) {
    return a > b ? a : b; // 返回较大值
  }
  void printHello() {
    cout << "Hello";
    // 无return，默认执行完函数体返回
  }
  ```
- **注意**：`return`后函数立即终止，后续代码不执行。

### 4. 函数重载（Overload）
- **核心概念**：同一作用域内，函数名相同但**参数列表不同**（参数个数/类型/顺序不同）的函数；
- **编译器匹配规则**：根据实参的类型和个数，自动匹配对应的函数；
- **示例**：
  ```cpp
  int add(int a, int b) { return a + b; }
  double add(double a, double b) { return a + b; } // 类型不同，构成重载
  int add(int a, int b, int c) { return a + b + c; } // 个数不同，构成重载

  cout << add(1,2) << endl; // 调用int add(int,int) → 3
  cout << add(1.5, 2.5) << endl; // 调用double add(double,double) →4.0
  cout << add(1,2,3) << endl; // 调用int add(int,int,int) →6
  ```
- **面试坑**：返回值类型不同**不能构成重载**（编译器无法通过返回值区分调用）。

### 5. 默认参数
- **作用**：给函数参数指定默认值，调用时可省略该参数；
- **语法**：参数声明时赋值；
- **示例**：
  ```cpp
  void printInfo(string name, int age = 18) { // age默认值18
    cout << "姓名：" << name << "，年龄：" << age << endl;
  }
  printInfo("Tom"); // 省略age，使用默认值18 → 姓名：Tom，年龄：18
  printInfo("Jerry", 20); // 显式传参，覆盖默认值 → 姓名：Jerry，年龄：20
  ```
- **规则**：默认参数必须从右往左连续指定（如`void func(int a=1, int b)` 错误）。

### 6. Lambda 简介（C++11+）
- **核心概念**：匿名函数（无函数名），可直接嵌入代码中，适合短小的函数逻辑；
- **语法**：`[捕获列表](参数列表) -> 返回值类型 { 函数体 }`（返回值类型可省略，编译器自动推导）；
- **示例**：
  ```cpp
  #include <iostream>
  using namespace std;

  int main() {
    // 无捕获、无参数、返回int的lambda
    auto add = []() -> int { return 1 + 2; };
    cout << add() << endl; // 输出3

    // 捕获外部变量（[=]值捕获，[&]引用捕获）、带参数的lambda
    int a = 1, b = 2;
    auto swap = [&]() { // [&]引用捕获a和b，可修改原变量
      int temp = a;
      a = b;
      b = temp;
    };
    swap();
    cout << a << "," << b; // 输出2,1
    return 0;
  }
  ```
- **核心用途**：配合STL算法（如`sort`、`for_each`）使用，简化代码（后续STL章节详细讲解）。

## 五、数组与字符串
### 1. 一维数组
#### （1）定义与初始化
- **语法**：`类型 数组名[数组长度];`（数组长度必须是常量表达式）；
- **初始化方式**：
  ```cpp
  // 方式1：完全初始化
  int arr1[3] = {1, 2, 3}; // 数组元素：[1,2,3]

  // 方式2：部分初始化（未初始化元素默认为0）
  int arr2[5] = {1, 2}; // 数组元素：[1,2,0,0,0]

  // 方式3：省略数组长度（编译器自动推导）
  int arr3[] = {1, 2, 3, 4}; // 长度为4

  // 方式4：C++11后支持列表初始化（省略=）
  int arr4[] = {1, 2, 3};
  ```

#### （2）数组访问与遍历
- 通过**下标**访问（从0开始）：`arr[i]`（i为下标，范围0~长度-1）；
- 遍历方式：
  ```cpp
  int arr[] = {1, 2, 3, 4, 5};
  int len = sizeof(arr) / sizeof(arr[0]); // 计算数组长度（总字节数/单个元素字节数）

  // 方式1：for循环
  for (int i = 0; i < len; i++) {
    cout << arr[i] << " "; // 输出1 2 3 4 5
  }

  // 方式2：C++11范围for（更简洁）
  for (int num : arr) {
    cout << num << " "; // 输出1 2 3 4 5
  }
  ```
- **易错点**：数组下标越界（如访问`arr[len]`），编译器不报错，但运行时可能崩溃（内存非法访问）。

### 2. 字符串：C风格字符串 vs `std::string`
#### （1）C风格字符串（兼容C语言）
- 本质：以`'\0'`（空字符，ASCII码0）结尾的字符数组；
- 定义方式：
  ```cpp
  char str1[] = "Hello"; // 自动添加'\0'，长度为6（H e l l o \0）
  char str2[] = {'H', 'i', '\0'}; // 必须手动添加'\0'，否则不是合法字符串
  char* str3 = "World"; // 字符串常量（存储在只读数据区，不可修改）
  ```
- **常用操作**（需包含`<cstring>`头文件）：
  ```cpp
  #include <cstring>
  char str1[] = "Hello", str2[] = "World";

  cout << strlen(str1); // 求长度（不含'\0'）→ 5
  strcpy(str1, str2); // 复制str2到str1（覆盖原内容，需确保str1足够大）
  strcat(str1, str2); // 拼接str2到str1末尾
  int cmp = strcmp(str1, str2); // 比较字符串（相等返回0，str1>str2返回正，否则负）
  ```
- **缺点**：不安全（无边界检查，易数组越界）、操作繁琐。

#### （2）`std::string`（C++标准字符串，推荐使用）
- 本质：`std`命名空间下的字符串类，封装了字符串操作，安全且便捷；
- 使用前提：包含`<string>`头文件 + `using namespace std;`；
- **常用操作**：
  ```cpp
  #include <string>
  string str = "Hello";

  // 访问
  cout << str[0]; // 下标访问 → 'H'
  cout << str.at(1); // at()访问（越界会抛异常，更安全）→ 'e'

  // 长度
  cout << str.size(); // 5
  cout << str.length(); // 5（与size()等价）

  // 拼接
  str += " World"; // 直接拼接 → "Hello World"
  str.append("!"); // 拼接 → "Hello World!"

  // 比较
  if (str == "Hello World!") {
    cout << "相等" << endl; // 直接用==比较，直观
  }

  // 查找
  int pos = str.find("World"); // 查找子串，返回起始下标 → 6
  if (pos != string::npos) { // 未找到返回string::npos
    cout << "找到子串" << endl;
  }

  // 截取子串
  string sub = str.substr(0, 5); // 从下标0开始，截取5个字符 → "Hello"
  ```
- **优势**：自动管理内存、支持直接用运算符（`+`、`==`、`[]`）、边界检查更安全，是C++开发的首选。

## 六、指针入门
### 1. 指针的核心概念：定义/解引用/取地址
- **指针本质**：存储变量**内存地址**的变量（地址是内存单元的编号，通常为4/8字节）；
- **核心操作符**：
  - `&`：取地址符 → 获得变量的内存地址；
  - `*`：解引用符 → 通过地址访问变量的值；
- **定义与使用示例**：
  ```cpp
  int a = 10;
  int* p = &a; // 定义int*类型指针p，存储a的地址（&a是a的地址）

  cout << &a; // 输出a的内存地址（如0x7ffee4b7e7ac）
  cout << p;  // 输出p存储的地址（与&a相同）
  cout << *p; // 解引用p，访问地址指向的变量 → 10（等价于a）

  *p = 20; // 通过指针修改a的值
  cout << a; // 输出20（a被修改）
  ```
- **语法注意**：`int* p`、`int *p`、`int * p` 等价，推荐`int* p`（更清晰表示`p`是指针）。

### 2. 指针与数组
- **核心结论**：数组名本质是**指向数组首元素的常量指针**（不能修改指向）；
- **等价关系**：`arr[i] == *(arr + i)`（数组下标访问本质是指针偏移）；
- **示例**：
  ```cpp
  int arr[] = {1, 2, 3, 4, 5};
  int* p = arr; // 等价于 int* p = &arr[0];（p指向数组首元素）

  cout << *p; // 访问首元素 → 1
  cout << *(p + 1); // 指针偏移1，访问arr[1] → 2
  cout << p[2]; // 指针也支持下标访问 → 3（等价于*(p+2)）

  p++; // 指针自增1，指向arr[1]（偏移量=元素类型字节数，int为4字节）
  cout << *p; // 输出2
  ```
- **面试考点**：数组名与指针的区别（数组名是常量指针，不能自增/自减；指针是变量，可修改指向）。

### 3. 指针与函数
- 指针作为函数参数：传递变量地址，实现“修改原变量”（即指针传递，前文已讲）；
- 函数指针：指向函数的指针（存储函数的入口地址）；
- **函数指针示例**：
  ```cpp
  // 定义一个函数
  int add(int a, int b) {
    return a + b;
  }

  int main() {
    // 定义函数指针：返回值类型(*指针名)(参数列表)
    int (*funcPtr)(int, int) = add; // funcPtr指向add函数

    // 通过函数指针调用函数
    int result = funcPtr(1, 2); // 等价于 add(1,2)
    cout << result; // 输出3
    return 0;
  }
  ```
- **用途**：实现回调函数（如排序算法中自定义比较规则），是C++多态的底层基础之一。

### 4. 野指针与 `nullptr`
#### （1）野指针（危险！）
- **定义**：未初始化、已释放或指向非法内存的指针；
- **危害**：解引用野指针会导致程序崩溃（内存非法访问），难以调试；
- **常见场景**：
  ```cpp
  int* p; // 未初始化，p的值是随机的（野指针）
  *p = 10; // 危险！访问非法内存

  int* q = new int(5);
  delete q; // 释放内存后，q成为野指针（指向已释放的内存）
  *q = 20; // 危险！
  ```

#### （2）`nullptr`（C++11+）
- **作用**：表示“空指针”（指向空地址），替代C语言的`NULL`（`NULL`本质是`0`，可能引发歧义）；
- **使用建议**：指针未明确指向时，初始化为`nullptr`；
- **示例**：
  ```cpp
  int* p = nullptr; // 初始化空指针
  if (p == nullptr) { // 判断指针是否为空（安全）
    cout << "p是空指针" << endl;
  }
  // *p = 10; // 编译不报错，但运行时崩溃（空指针不能解引用）
  ```
- **面试考点**：`nullptr`与`NULL`的区别（`nullptr`是指针类型，`NULL`是整型常量`0`，避免重载歧义）。

### 5. 指针和引用的核心区别（面试高频）
| 维度 | 指针（`*`） | 引用（`&`） |
|------|-------------|-------------|
| 本质 | 存储变量地址的变量 | 变量的别名（底层是指针的语法糖） |
| 初始化 | 可空初始化（`nullptr`），可后赋值 | 必须初始化（绑定一个变量），不能改绑 |
| 空值 | 支持`nullptr`（空指针） | 不支持空引用（必须绑定有效变量） |
| 自增自减 | 可自增/自减（修改指向） | 不支持（自增/自减是修改绑定变量的值） |
| 多级 | 支持多级指针（`int** p`） | 不支持多级引用（`int&& r`是右值引用，非多级） |
| 安全性 | 存在野指针风险，需手动判空 | 更安全（无空引用），无需判空 |
| 语法 | 解引用（`*p`）、取地址（`&p`） | 直接使用（`r`等价于原变量） |
| 适用场景 | 动态内存分配、函数指针、多级间接访问 | 函数参数传递、返回值（避免拷贝）、日常变量别名 |

- **核心总结**：优先使用引用（安全简洁），需要“空指针”或“修改指向”时使用指针。
