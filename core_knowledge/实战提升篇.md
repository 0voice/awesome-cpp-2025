# 实战提升篇
实战提升篇聚焦 C++ 工程化开发核心能力，涵盖**设计模式、多线程编程、性能优化、工程化规范**四大核心模块，帮助开发者从“会用语法”升级到“能做项目”，解决实际开发中的复杂问题。

## 一、设计模式
设计模式是解决特定场景下通用问题的成熟方案，是前人总结的工程化经验结晶。掌握核心设计模式能大幅提升代码的可复用性、可维护性和扩展性，是中高级 C++ 开发的必备技能。

### 1. 设计模式核心原则（SOLID）
设计模式的基础是 5 大设计原则，所有模式都围绕这些原则展开：
- **单一职责原则（SRP）**：一个类只负责一项职责，避免功能耦合；
- **开放封闭原则（OCP）**：对扩展开放，对修改关闭（通过抽象/接口扩展功能，而非修改原有代码）；
- **里氏替换原则（LSP）**：子类可替换父类，且不影响程序正确性（子类需兼容父类接口）；
- **接口隔离原则（ISP）**：客户端不应依赖不需要的接口，拆分臃肿接口为专用接口；
- **依赖倒置原则（DIP）**：依赖抽象（接口/基类），不依赖具体实现（高层模块不依赖低层模块，两者都依赖抽象）。

### 2. C++ 高频设计模式实战
#### （1）单例模式（Singleton）
- **核心场景**：确保一个类只有一个实例，且提供全局唯一访问点（如配置管理器、日志器、数据库连接池）；
- **核心要求**：线程安全、禁止拷贝、自动释放资源；
- **推荐实现：C++11 静态局部变量版（最简洁安全）**

```cpp
#include <mutex>
#include <iostream>
using namespace std;

class ConfigManager {
private:
    // 私有构造函数（禁止外部实例化）
    ConfigManager() {
        // 初始化：加载配置文件（模拟）
        cout << "ConfigManager 初始化，加载配置文件" << endl;
    }

    // 私有析构函数（禁止外部销毁）
    ~ConfigManager() {
        // 释放资源：保存配置（模拟）
        cout << "ConfigManager 析构，保存配置" << endl;
    }

    // 禁止拷贝和移动（C++11+）
    ConfigManager(const ConfigManager&) = delete;
    ConfigManager& operator=(const ConfigManager&) = delete;
    ConfigManager(ConfigManager&&) = delete;
    ConfigManager& operator=(ConfigManager&&) = delete;

public:
    // 全局访问点：静态成员函数
    static ConfigManager& GetInstance() {
        // C++11 后，静态局部变量初始化是线程安全的
        static ConfigManager instance;
        return instance;
    }

    // 业务接口：获取配置
    string GetConfig(const string& key) {
        // 模拟配置存储
        if (key == "timeout") return "30s";
        if (key == "max_conn") return "1000";
        return "default";
    }
};

// 测试：多线程环境下访问单例
void ThreadFunc() {
    string timeout = ConfigManager::GetInstance().GetConfig("timeout");
    cout << "线程 " << this_thread::get_id() << " 获取超时配置：" << timeout << endl;
}

int main() {
    // 单线程访问
    ConfigManager& config1 = ConfigManager::GetInstance();
    ConfigManager& config2 = ConfigManager::GetInstance();
    cout << "config1 与 config2 是否为同一实例：" << (&config1 == &config2) << endl; // true

    // 多线程访问（验证线程安全）
    thread t1(ThreadFunc);
    thread t2(ThreadFunc);
    t1.join();
    t2.join();

    return 0;
}
```

- **关键说明**：
  1. 私有构造/析构 + 删除拷贝/移动函数，确保无法外部实例化或拷贝；
  2. 静态局部变量初始化的线程安全性由 C++11 标准保证，无需手动加锁；
  3. 实例生命周期与程序一致，析构时自动释放资源，无内存泄漏。

#### （2）工厂模式（Factory）
- **核心场景**：封装对象创建逻辑，解耦对象创建与使用（如根据配置创建不同类型的数据库连接、日志器）；
- **分类**：简单工厂（静态工厂）、工厂方法、抽象工厂（复杂度递增）；
- **实战：工厂方法模式（支持扩展，符合开放封闭原则）**

```cpp
#include <string>
#include <memory>
#include <iostream>
using namespace std;

// 抽象产品：日志器接口（依赖抽象）
class Logger {
public:
    virtual ~Logger() = default; // 虚析构，确保派生类析构
    virtual void Log(const string& msg) = 0; // 纯虚函数，定义接口
};

// 具体产品1：控制台日志器
class ConsoleLogger : public Logger {
public:
    void Log(const string& msg) override {
        cout << "[Console] " << msg << endl;
    }
};

// 具体产品2：文件日志器
class FileLogger : public Logger {
public:
    void Log(const string& msg) override {
        // 模拟写入文件
        cout << "[File] " << msg << endl;
    }
};

// 抽象工厂：日志器工厂接口
class LoggerFactory {
public:
    virtual ~LoggerFactory() = default;
    virtual unique_ptr<Logger> CreateLogger() = 0;
};

// 具体工厂1：控制台日志器工厂
class ConsoleLoggerFactory : public LoggerFactory {
public:
    unique_ptr<Logger> CreateLogger() override {
        return make_unique<ConsoleLogger>();
    }
};

// 具体工厂2：文件日志器工厂
class FileLoggerFactory : public LoggerFactory {
public:
    unique_ptr<Logger> CreateLogger() override {
        return make_unique<FileLogger>();
    }
};

// 客户端代码（依赖抽象，不依赖具体实现）
void ClientCode(LoggerFactory& factory) {
    unique_ptr<Logger> logger = factory.CreateLogger();
    logger->Log("系统启动成功");
    logger->Log("处理用户请求");
}

int main() {
    // 场景1：使用控制台日志
    ConsoleLoggerFactory consoleFactory;
    ClientCode(consoleFactory);

    // 场景2：切换为文件日志（无需修改客户端代码，符合开放封闭原则）
    FileLoggerFactory fileFactory;
    ClientCode(fileFactory);

    return 0;
}
```

- **核心优势**：
  1. 新增日志类型（如网络日志器）时，只需新增“具体产品类”和“具体工厂类”，无需修改客户端代码；
  2. 解耦对象创建与使用，客户端仅依赖抽象接口，代码灵活性高。

#### （3）观察者模式（Observer）
- **核心场景**：定义对象间的一对多依赖，当一个对象状态变化时，所有依赖它的对象都会收到通知并自动更新（如事件通知、消息订阅）；
- **核心角色**：主题（Subject，被观察对象）、观察者（Observer，接收通知的对象）；
- **实战：事件通知系统**

```cpp
#include <vector>
#include <memory>
#include <string>
#include <iostream>
using namespace std;

// 前向声明：主题类需要知道观察者类
class Subject;

// 观察者接口
class Observer {
public:
    virtual ~Observer() = default;
    virtual void Update(Subject* subject, const string& msg) = 0; // 接收通知
};

// 主题类（被观察对象）
class Subject {
private:
    vector<weak_ptr<Observer>> observers_; // 用 weak_ptr 避免循环引用
    mutex mtx_; // 线程安全

public:
    // 注册观察者
    void Attach(shared_ptr<Observer> observer) {
        lock_guard<mutex> lock(mtx_);
        observers_.emplace_back(observer);
    }

    // 移除观察者
    void Detach(Observer* observer) {
        lock_guard<mutex> lock(mtx_);
        observers_.erase(
            remove_if(observers_.begin(), observers_.end(),
                [observer](const weak_ptr<Observer>& wp) {
                    return wp.expired() || wp.lock().get() == observer;
                }),
            observers_.end()
        );
    }

    // 通知所有观察者
    void Notify(const string& msg) {
        lock_guard<mutex> lock(mtx_);
        for (auto it = observers_.begin(); it != observers_.end();) {
            if (auto sp = it->lock()) { // 检查观察者是否存活
                sp->Update(this, msg);
                ++it;
            } else {
                it = observers_.erase(it); // 清理已销毁的观察者
            }
        }
    }
};

// 具体主题：消息中心
class MessageCenter : public Subject {
public:
    void SendMessage(const string& msg) {
        cout << "\nMessageCenter 发送消息：" << msg << endl;
        Notify(msg); // 通知所有观察者
    }
};

// 具体观察者1：手机客户端
class MobileClient : public Observer {
private:
    string name_;
public:
    MobileClient(const string& name) : name_(name) {}
    void Update(Subject* subject, const string& msg) override {
        cout << "MobileClient[" << name_ << "] 收到消息：" << msg << endl;
    }
};

// 具体观察者2：PC客户端
class PCClient : public Observer {
private:
    string name_;
public:
    PCClient(const string& name) : name_(name) {}
    void Update(Subject* subject, const string& msg) override {
        cout << "PCClient[" << name_ << "] 收到消息：" << msg << endl;
    }
};

int main() {
    // 创建主题
    MessageCenter msgCenter;

    // 创建观察者（用 shared_ptr 管理生命周期）
    auto mobile1 = make_shared<MobileClient>("小明的手机");
    auto mobile2 = make_shared<MobileClient>("小红的手机");
    auto pc1 = make_shared<PCClient>("小刚的电脑");

    // 注册观察者
    msgCenter.Attach(mobile1);
    msgCenter.Attach(mobile2);
    msgCenter.Attach(pc1);

    // 发送消息（所有观察者收到通知）
    msgCenter.SendMessage("今天下午3点开会");

    // 移除一个观察者
    msgCenter.Detach(mobile2.get());
    msgCenter.SendMessage("会议地点改为3楼会议室");

    return 0;
}
```

- **关键说明**：
  1. 主题用 `weak_ptr` 存储观察者，避免 `shared_ptr` 循环引用导致内存泄漏；
  2. 支持动态注册/移除观察者，符合开放封闭原则；
  3. 加锁保证多线程环境下的线程安全。

#### （4）其他高频模式
- **策略模式**：封装不同算法，允许动态切换（如排序算法、支付方式）；
- **建造者模式**：分步构建复杂对象（如配置复杂的对象、协议包）；
- **适配器模式**：将一个类的接口转换为客户端期望的另一个接口（如旧系统接口适配新系统）；
- **装饰器模式**：动态给对象添加额外功能（如日志装饰、缓存装饰）。

### 3. 设计模式使用原则
- **不滥用**：设计模式是“解决方案”，不是“银弹”，简单问题无需过度设计；
- **优先接口/抽象**：依赖抽象而非具体实现，是设计模式的核心思想；
- **结合语言特性**：C++ 中用智能指针避免内存泄漏、用虚函数实现多态、用 lambda 简化回调，让设计模式实现更简洁；
- **关注工程价值**：设计模式的最终目的是提升代码可维护性和扩展性，而非炫技。

## 二、多线程编程
多线程是提升程序性能的核心手段（充分利用多核 CPU），但也带来了线程安全、同步互斥等问题。C++11 引入了标准线程库（`<thread>`），统一了多线程编程接口，替代了平台相关的 pthread（Linux）、CreateThread（Windows）。

### 1. 线程基础（`std::thread`）
#### （1）线程创建与启动
`std::thread` 是线程类，创建对象时指定线程函数，自动启动线程。核心注意事项：
- 线程函数可以是函数指针、函数对象、lambda 表达式；
- 线程启动后必须调用 `join()`（等待线程结束）或 `detach()`（分离线程，让线程后台运行），否则程序退出时会调用 `std::terminate()` 终止；
- 传递参数时，默认是按值拷贝，若需传递引用，需用 `std::ref()` 包装。

```cpp
#include <thread>
#include <string>
#include <iostream>
using namespace std;

// 线程函数1：普通函数
void ThreadFunc1(int a, string msg) {
    cout << "ThreadFunc1：a=" << a << "，msg=" << msg << endl;
}

// 线程函数2：函数对象
class ThreadObj {
public:
    void operator()(int a) {
        cout << "ThreadObj：a=" << a << endl;
    }
};

int main() {
    // 1. 用普通函数创建线程
    thread t1(ThreadFunc1, 10, "hello");

    // 2. 用函数对象创建线程
    ThreadObj obj;
    thread t2(obj, 20);

    // 3. 用 lambda 创建线程（最常用）
    thread t3([](int a, string msg) {
        cout << "lambda 线程：a=" << a << "，msg=" << msg << endl;
    }, 30, "world");

    // 等待线程结束（必须调用 join() 或 detach()）
    t1.join();
    t2.join();
    t3.join();

    cout << "主线程结束" << endl;
    return 0;
}
```

#### （2）线程属性
- **线程 ID**：用 `this_thread::get_id()` 获取当前线程 ID；
- **线程休眠**：用 `this_thread::sleep_for(duration)` 让线程休眠（如 `sleep_for(chrono::seconds(1))` 休眠 1 秒）；
- **线程交换**：用 `swap(t1, t2)` 或 `t1.swap(t2)` 交换两个线程的资源。

```cpp
#include <thread>
#include <chrono>
#include <iostream>
using namespace std;

void SleepFunc() {
    cout << "线程 " << this_thread::get_id() << " 开始休眠" << endl;
    this_thread::sleep_for(chrono::milliseconds(500)); // 休眠 500ms
    cout << "线程 " << this_thread::get_id() << " 休眠结束" << endl;
}

int main() {
    thread t(SleepFunc);
    cout << "线程 t 的 ID：" << t.get_id() << endl;
    t.join();
    return 0;
}
```

### 2. 线程同步与互斥
多线程访问共享资源时，会出现“竞态条件”（Race Condition），导致数据错误。线程同步的核心是“保证共享资源的原子操作”，C++ 提供了 `mutex`、`lock_guard`、`unique_lock` 等工具。

#### （1）互斥锁（`std::mutex`）
`std::mutex` 是最基础的互斥锁，提供 `lock()`（加锁）和 `unlock()`（解锁）接口，核心规则：
- 同一时间只有一个线程能成功加锁，其他线程会阻塞直到锁被释放；
- 必须保证 `lock()` 和 `unlock()` 成对出现（避免死锁或资源泄漏）；
- 推荐用 `lock_guard` 或 `unique_lock` 自动管理锁（RAII 原则）。

```cpp
#include <thread>
#include <mutex>
#include <iostream>
using namespace std;

int g_count = 0; // 共享资源
mutex g_mutex;   // 互斥锁

// 线程函数：对共享资源进行累加
void Increment() {
    for (int i = 0; i < 100000; ++i) {
        // 方式1：手动加锁解锁（不推荐，容易遗漏 unlock()）
        // g_mutex.lock();
        // ++g_count;
        // g_mutex.unlock();

        // 方式2：lock_guard（RAII，自动加锁解锁，推荐）
        lock_guard<mutex> lock(g_mutex);
        ++g_count; // 临界区：原子操作
    }
}

int main() {
    thread t1(Increment);
    thread t2(Increment);

    t1.join();
    t2.join();

    cout << "最终计数：" << g_count << endl; // 正确输出 200000（无竞态条件）
    return 0;
}
```

#### （2）`unique_lock`（灵活的锁管理）
`lock_guard` 是简单锁管理（构造加锁，析构解锁），`unique_lock` 更灵活，支持：
- 延迟加锁（`std::defer_lock`）；
- 尝试加锁（`try_lock()`）；
- 超时加锁（`try_lock_for()`）；
- 手动解锁（`unlock()`）。

```cpp
#include <thread>
#include <mutex>
#include <chrono>
#include <iostream>
using namespace std;

mutex g_mutex;

void TryLockFunc() {
    unique_lock<mutex> lock(g_mutex, defer_lock); // 延迟加锁
    if (lock.try_lock_for(chrono::milliseconds(100))) { // 超时 100ms 尝试加锁
        cout << "线程 " << this_thread::get_id() << " 加锁成功" << endl;
        this_thread::sleep_for(chrono::milliseconds(200)); // 持有锁 200ms
        // 析构时自动解锁
    } else {
        cout << "线程 " << this_thread::get_id() << " 加锁失败（超时）" << endl;
    }
}

int main() {
    thread t1(TryLockFunc);
    thread t2(TryLockFunc);

    t1.join();
    t2.join();
    return 0;
}
```

#### （3）条件变量（`std::condition_variable`）
条件变量用于线程间通信，让一个线程等待某个条件满足后再继续执行（如生产者-消费者模型）。核心接口：
- `wait(lock)`：释放锁，阻塞线程，直到被 `notify_one()` 或 `notify_all()` 唤醒；
- `notify_one()`：唤醒一个等待的线程；
- `notify_all()`：唤醒所有等待的线程。

```cpp
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <iostream>
using namespace std;

const int MAX_QUEUE_SIZE = 5;
queue<int> g_queue;       // 共享队列（生产者生产，消费者消费）
mutex g_mutex;            // 互斥锁
condition_variable g_cv;  // 条件变量

// 生产者线程：生产数据放入队列
void Producer() {
    for (int i = 1; i <= 10; ++i) {
        unique_lock<mutex> lock(g_mutex);

        // 等待队列不满（避免队列溢出）
        g_cv.wait(lock, []() { return g_queue.size() < MAX_QUEUE_SIZE; });

        // 生产数据
        g_queue.push(i);
        cout << "生产者生产：" << i << "，队列大小：" << g_queue.size() << endl;

        lock.unlock();
        g_cv.notify_one(); // 唤醒一个消费者

        this_thread::sleep_for(chrono::milliseconds(100)); // 模拟生产耗时
    }
}

// 消费者线程：从队列获取数据消费
void Consumer() {
    while (true) {
        unique_lock<mutex> lock(g_mutex);

        // 等待队列不为空（避免消费空队列）
        g_cv.wait(lock, []() { return !g_queue.empty(); });

        // 消费数据
        int data = g_queue.front();
        g_queue.pop();
        cout << "消费者消费：" << data << "，队列大小：" << g_queue.size() << endl;

        lock.unlock();
        g_cv.notify_one(); // 唤醒一个生产者

        if (data == 10) break; // 消费完最后一个数据退出
        this_thread::sleep_for(chrono::milliseconds(200)); // 模拟消费耗时
    }
}

int main() {
    thread producer(Producer);
    thread consumer(Consumer);

    producer.join();
    consumer.join();
    return 0;
}
```

#### （4）原子操作（`std::atomic`）
对于简单的共享变量（如计数器），使用 `atomic` 比 `mutex` 更高效（无需加锁，直接操作内存）。`atomic` 支持原子的增、减、赋值等操作，线程安全。

```cpp
#include <thread>
#include <atomic>
#include <iostream>
using namespace std;

atomic<int> g_count = 0; // 原子变量（线程安全）

void Increment() {
    for (int i = 0; i < 100000; ++i) {
        ++g_count; // 原子操作，无需加锁
    }
}

int main() {
    thread t1(Increment);
    thread t2(Increment);

    t1.join();
    t2.join();

    cout << "最终计数：" << g_count << endl; // 正确输出 200000
    return 0;
}
```

### 3. 线程安全与死锁
#### （1）线程安全的核心原则
- **最小临界区**：只对共享资源的操作加锁，避免大面积代码阻塞；
- **避免共享可变状态**：尽量使用局部变量，或通过消息传递（而非共享内存）实现线程通信；
- **优先原子操作**：简单变量用 `atomic`，复杂场景用 `mutex`；
- **禁止在临界区调用外部接口**：外部接口可能再次加锁，导致死锁。

#### （2）死锁及避免
死锁是多线程编程的噩梦，指两个或多个线程互相等待对方释放锁，导致程序永久阻塞。死锁的 4 个必要条件：
1. 互斥：资源只能被一个线程持有；
2. 持有并等待：线程持有一个锁，同时等待另一个锁；
3. 不可剥夺：线程持有的锁不能被强制剥夺；
4. 循环等待：线程间形成循环等待链（如 T1 等 T2 的锁，T2 等 T1 的锁）。

**死锁避免方案**：
- 按固定顺序加锁：所有线程都按相同的顺序获取多个锁（如先锁 A 再锁 B）；
- 超时加锁：用 `unique_lock::try_lock_for()`，超时后释放已持有锁并重试；
- 避免持有多个锁：尽量设计为单个锁，或用 `std::lock()` 同时加多个锁（原子操作，避免部分加锁）；
- 减少锁的持有时间：获取锁后尽快完成操作，释放锁。

**死锁示例（错误）**：
```cpp
mutex mutexA;
mutex mutexB;

// 线程1：先锁A再锁B
void Thread1() {
    mutexA.lock();
    this_thread::sleep_for(chrono::milliseconds(100)); // 让线程2有时间锁B
    mutexB.lock(); // 死锁：等待线程2释放B
    // 业务逻辑
    mutexB.unlock();
    mutexA.unlock();
}

// 线程2：先锁B再锁A
void Thread2() {
    mutexB.lock();
    this_thread::sleep_for(chrono::milliseconds(100)); // 让线程1有时间锁A
    mutexA.lock(); // 死锁：等待线程1释放A
    // 业务逻辑
    mutexA.unlock();
    mutexB.unlock();
}
```

**修复方案（按固定顺序加锁）**：
```cpp
// 线程1和线程2都按“先A后B”的顺序加锁
void Thread1() {
    mutexA.lock();
    mutexB.lock();
    // 业务逻辑
    mutexB.unlock();
    mutexA.unlock();
}

void Thread2() {
    mutexA.lock();
    mutexB.lock();
    // 业务逻辑
    mutexB.unlock();
    mutexA.unlock();
}
```

### 4. 高级多线程技术
#### （1）线程池
线程池是“预先创建多个线程，复用线程处理任务”的技术，避免频繁创建/销毁线程的开销（线程创建销毁是重量级操作）。核心组件：
- 任务队列：存储待执行的任务；
- 线程池：多个工作线程，循环从任务队列获取任务执行；
- 管理接口：添加任务、关闭线程池。

```cpp
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <functional>
#include <vector>
#include <atomic>
#include <iostream>
using namespace std;

class ThreadPool {
public:
    // 构造函数：创建n个工作线程
    explicit ThreadPool(size_t thread_num) : stop_(false) {
        for (size_t i = 0; i < thread_num; ++i) {
            workers_.emplace_back([this]() {
                while (true) {
                    function<void()> task;
                    {
                        unique_lock<mutex> lock(mtx_);
                        // 等待任务或停止信号
                        cv_.wait(lock, [this]() { return stop_ || !tasks_.empty(); });
                        // 若停止且任务队列为空，退出线程
                        if (stop_ && tasks_.empty()) return;
                        // 获取任务
                        task = move(tasks_.front());
                        tasks_.pop();
                    }
                    task(); // 执行任务
                }
            });
        }
    }

    // 析构函数：关闭线程池
    ~ThreadPool() {
        {
            unique_lock<mutex> lock(mtx_);
            stop_ = true;
        }
        cv_.notify_all(); // 唤醒所有工作线程
        for (thread& worker : workers_) {
            worker.join(); // 等待所有线程结束
        }
    }

    // 添加任务（支持任意函数和参数）
    template <typename F, typename... Args>
    void AddTask(F&& f, Args&&... args) {
        {
            unique_lock<mutex> lock(mtx_);
            // 禁止在停止后添加任务
            if (stop_) throw runtime_error("线程池已关闭，无法添加任务");
            // 封装任务（完美转发）
            tasks_.emplace([=]() {
                forward<F>(f)(forward<Args>(args)...);
            });
        }
        cv_.notify_one(); // 唤醒一个工作线程
    }

private:
    vector<thread> workers_;       // 工作线程列表
    queue<function<void()>> tasks_; // 任务队列
    mutex mtx_;                    // 互斥锁
    condition_variable cv_;         // 条件变量
    atomic<bool> stop_;            // 停止标志（原子变量，线程安全）
};

// 测试任务：计算a + b
int Add(int a, int b) {
    this_thread::sleep_for(chrono::milliseconds(100)); // 模拟任务耗时
    return a + b;
}

int main() {
    ThreadPool pool(4); // 创建4个线程的线程池

    // 添加10个任务
    for (int i = 0; i < 10; ++i) {
        pool.AddTask([i]() {
            int result = Add(i, i * 2);
            cout << "线程 " << this_thread::get_id() << " 完成任务：" << i << " + " << i*2 << " = " << result << endl;
        });
    }

    // 等待所有任务完成（这里简单休眠，实际可通过future实现）
    this_thread::sleep_for(chrono::seconds(2));

    return 0;
}
```

#### （2）`std::future` 与 `std::promise`
`future` 和 `promise` 用于线程间数据传递（获取异步任务的返回值）：
- `promise`：生产者线程设置值；
- `future`：消费者线程获取值（会阻塞直到值被设置）。

```cpp
#include <thread>
#include <future>
#include <iostream>
using namespace std;

// 生产者线程：计算结果并设置到promise
void Calculate(promise<int> prom) {
    this_thread::sleep_for(chrono::seconds(1));
    int result = 100 + 200;
    prom.set_value(result); // 设置结果
}

int main() {
    // 创建promise和future
    promise<int> prom;
    future<int> fut = prom.get_future();

    // 启动线程，传递promise（必须移动，因为promise不可拷贝）
    thread t(Calculate, move(prom));

    // 获取结果（阻塞直到set_value被调用）
    cout << "等待计算结果..." << endl;
    int result = fut.get(); // 只能调用一次get()
    cout << "计算结果：" << result << endl;

    t.join();
    return 0;
}
```

#### （3）`std::async`（异步任务）
`async` 是更高层次的异步编程接口，自动创建线程（或复用线程池）执行任务，并返回 `future` 用于获取结果。无需手动管理线程和 `promise`。

```cpp
#include <future>
#include <iostream>
using namespace std;

int Calculate() {
    this_thread::sleep_for(chrono::seconds(1));
    return 300 + 400;
}

int main() {
    // 启动异步任务（默认创建新线程）
    future<int> fut = async(Calculate);

    cout << "等待异步任务结果..." << endl;
    int result = fut.get();
    cout << "异步任务结果：" << result << endl;

    return 0;
}
```

## 三、性能优化
C++ 的核心优势是“高性能”，性能优化是 C++ 开发的核心竞争力。优化的核心原则是“先测量，后优化”（通过 Profiler 定位瓶颈，避免盲目优化）。

### 1. 代码层优化
#### （1）减少拷贝，多用移动
拷贝操作（尤其是大对象）会消耗大量内存和 CPU，C++11 后的移动语义（`std::move`）可避免不必要的拷贝。

```cpp
#include <vector>
#include <string>
#include <iostream>
using namespace std;

int main() {
    vector<string> vec;
    string s = "hello world";

    // 方式1：拷贝（创建新字符串，效率低）
    vec.push_back(s);
    cout << "拷贝后 s 是否为空：" << s.empty() << endl; // false

    // 方式2：移动（转移所有权，效率高，s变为空）
    vec.push_back(move(s));
    cout << "移动后 s 是否为空：" << s.empty() << endl; // true

    return 0;
}
```

- **优化场景**：
  1. 函数返回大对象时，返回值会自动移动（C++11 后 NRVO 优化）；
  2. 容器添加元素时，对临时对象或不再使用的对象用 `move`；
  3. 自定义类实现移动构造/移动赋值运算符（Rule of Five）。

#### （2）避免不必要的内存分配
内存分配（`new`/`malloc`）是耗时操作，频繁分配会导致内存碎片和性能下降。

- **优化方案**：
  1. 预分配内存：`vector::reserve()` 预分配容量，避免频繁扩容；
  2. 对象池：复用对象（如线程池、连接池），减少创建/销毁开销；
  3. 栈内存优先：小对象用栈内存（局部变量），避免堆内存分配；
  4. 避免临时对象：如用 `emplace_back()` 替代 `push_back()`（原地构造对象，避免临时对象）。

```cpp
#include <vector>
#include <string>
using namespace std;

struct Person {
    string name;
    int age;
    Person(string n, int a) : name(n), age(a) {}
};

int main() {
    vector<Person> vec;
    vec.reserve(100); // 预分配100个元素的容量，避免扩容

    // emplace_back：原地构造Person，无需创建临时对象
    vec.emplace_back("Tom", 18);

    // push_back：创建临时Person，再拷贝/移动到容器
    vec.push_back(Person("Jerry", 17));

    return 0;
}
```

#### （3）循环优化
循环是性能热点，优化循环能大幅提升性能：
- 减少循环内的计算：将不变的计算移到循环外；
- 减少循环内的函数调用：函数调用有开销，可内联（`inline`）或手动展开；
- 缓存友好：按内存顺序访问数据（CPU 缓存是按块加载的，连续访问命中率高）；
- 循环展开：减少循环控制开销（适用于循环次数固定的场景）。

```cpp
// 优化前：循环内重复计算
for (int i = 0; i < vec.size(); ++i) {
    // vec.size() 每次循环都要计算（vector的size是O(1)，但仍有开销）
}

// 优化后：将size移到循环外
int size = vec.size();
for (int i = 0; i < size; ++i) {
    // ...
}

// 缓存友好：连续访问数组（CPU缓存命中率高）
int arr[1000];
for (int i = 0; i < 1000; ++i) {
    arr[i] = i; // 连续访问，缓存友好
}

// 非缓存友好：跳跃访问（缓存命中率低）
for (int i = 0; i < 1000; i += 100) {
    arr[i] = i; // 跳跃访问，缓存失效频繁
}
```

#### （4）使用高效的数据结构和算法
- 查找场景：`unordered_map`（平均 O(1)）优于 `map`（O(log n)），需有序时用 `map`；
- 排序场景：`sort`（快速排序）优于冒泡排序、插入排序；
- 容器选择：根据操作场景选择（如频繁尾部增删用 `vector`，中间增删用 `list`）；
- 避免使用低效算法：如嵌套循环（O(n²)），尽量用 O(n) 或 O(n log n) 算法。

### 2. 编译优化
编译器优化是“零成本”优化，通过编译器参数开启优化，无需修改代码：
- **GCC/Clang**：`-O1`（基础优化）、`-O2`（常用优化，平衡速度和编译时间）、`-O3`（极致优化，可能增大二进制体积）；
- **MSVC**：`/O1`（最小化体积）、`/O2`（最大化速度）。

编译器优化的核心内容：
- 常量折叠：计算编译期常量（如 `3+5` 直接优化为 `8`）；
- 死代码消除：删除永远不会执行的代码；
- 循环优化：循环展开、循环变量外提；
- 函数内联：消除函数调用开销；
- 指令重排：优化指令执行顺序，充分利用 CPU 流水线。

### 3. 内存优化
#### （1）减少内存碎片
内存碎片是频繁分配/释放不同大小的堆内存导致的，会浪费内存并降低分配效率：
- 用 `vector` 替代多个独立的 `new`：`vector` 是连续内存，减少碎片；
- 使用内存池：预先分配一块大内存，按需分配小块内存，释放时归还给内存池；
- 对齐内存：`alignas` 指定内存对齐（CPU 访问对齐的内存更快）。

```cpp
// 指定内存对齐为8字节
struct alignas(8) Data {
    int a;
    char b;
};

// 内存池示例（简化）
class MemoryPool {
private:
    char* pool_;
    size_t size_;
    size_t used_;
public:
    MemoryPool(size_t size) : size_(size), used_(0) {
        pool_ = new char[size];
    }
    ~MemoryPool() {
        delete[] pool_;
    }
    void* Allocate(size_t alloc_size) {
        if (used_ + alloc_size > size_) return nullptr;
        void* ptr = pool_ + used_;
        used_ += alloc_size;
        return ptr;
    }
    void Deallocate(void* ptr) {
        // 简化实现：不实际释放，仅重置used_（适用于批量释放场景）
        if (ptr == pool_) used_ = 0;
    }
};
```

#### （2）缓存优化
CPU 缓存是提升内存访问速度的关键（缓存速度比内存快 10-100 倍），优化缓存命中率：
- 数据局部性：将频繁访问的数据放在一起（如结构体成员按访问频率排序）；
- 避免缓存失效：减少对同一缓存行的并发写（伪共享）；
- 预取数据：`__builtin_prefetch`（GCC）或 `_mm_prefetch`（MSVC）手动预取数据到缓存。

### 4. 性能分析工具
优化的前提是找到性能瓶颈，常用工具：
- **GCC/Clang**：`gprof`（简单性能分析）、`perf`（Linux 系统级性能分析）；
- **Windows**：Visual Studio 性能探查器；
- **跨平台**：Valgrind（内存泄漏+性能分析）、Google Benchmark（基准测试）。

**Google Benchmark 示例（基准测试）**：
```cpp
#include <benchmark/benchmark.h>
#include <vector>

// 测试vector::push_back vs emplace_back
static void BM_VectorPushBack(benchmark::State& state) {
    std::vector<int> vec;
    vec.reserve(state.range(0));
    for (auto _ : state) {
        vec.push_back(10);
    }
}
BENCHMARK(BM_VectorPushBack)->Range(8, 8<<10);

static void BM_VectorEmplaceBack(benchmark::State& state) {
    std::vector<int> vec;
    vec.reserve(state.range(0));
    for (auto _ : state) {
        vec.emplace_back(10);
    }
}
BENCHMARK(BM_VectorEmplaceBack)->Range(8, 8<<10);

BENCHMARK_MAIN();
```

## 四、工程化规范与实践
工程化开发的核心是“让代码可维护、可协作、可扩展”，涵盖编码规范、版本控制、构建系统、测试等多个方面。

### 1. 编码规范
编码规范是团队协作的基础，统一的风格能减少沟通成本，提升代码可读性。推荐遵循：
- **Google C++ 编码规范**：最流行的规范，涵盖命名、格式、注释、特性使用等；
- **ISO C++ Core Guidelines**：C++ 标准委员会推荐的指南，聚焦安全性、高效性和可维护性。

#### 核心规范要点
- **命名**：
  - 类/结构体/枚举：大驼峰（`PersonInfo`、`LogLevel`）；
  - 函数/变量：小驼峰（`calculateSum`、`userName`）或下划线（`calculate_sum`、`user_name`）；
  - 常量/宏：全大写+下划线（`MAX_QUEUE_SIZE`、`LOG_DEBUG`）；
  - 私有成员：后缀加下划线（`name_`、`age_`）。
- **格式**：
  - 缩进：4 个空格（避免 Tab，跨编辑器一致）；
  - 行宽：不超过 80-120 字符；
  - 大括号：函数/类的左大括号单独一行，循环/条件的左大括号紧跟语句。
- **注释**：
  - 类/函数：用 Doxygen 风格注释（说明功能、参数、返回值、异常）；
  - 复杂逻辑：添加行注释，说明设计思路；
  - 避免冗余注释（如“i++：i自增1”）。
- **特性使用**：
  - 禁用裸 `new/delete`，用智能指针；
  - 禁用宏，用 `constexpr` 或 `inline` 函数；
  - 优先使用标准库，避免重复造轮子；
  - 避免使用 `void*`、裸数组，用 `std::any`、`std::vector`。

### 2. 构建系统
构建系统用于管理代码编译、链接、依赖，替代手动写 Makefile（复杂项目难以维护）。C++ 常用构建系统：

#### （1）CMake（最流行，跨平台）
CMake 是“元构建系统”，通过 `CMakeLists.txt` 定义构建规则，生成 Makefile（Linux）、Visual Studio 解决方案（Windows）等。

**简单 CMakeLists.txt 示例**：
```cmake
# 最低 CMake 版本要求
cmake_minimum_required(VERSION 3.10)

# 项目名称和版本
project(MyProject VERSION 1.0 LANGUAGES CXX)

# 设置 C++ 标准（C++11+）
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 查找依赖库（如 Boost、OpenCV）
# find_package(Boost REQUIRED COMPONENTS system thread)

# 添加可执行文件（源文件列表）
add_executable(MyApp 
    src/main.cpp
    src/logger.cpp
    src/config.cpp
)

# 添加头文件目录
target_include_directories(MyApp PUBLIC
    ${PROJECT_SOURCE_DIR}/include
)

# 链接依赖库
# target_link_libraries(MyApp PUBLIC Boost::system Boost::thread)

# 编译选项（如优化级别、警告级别）
if(CMAKE_BUILD_TYPE STREQUAL "Release")
    target_compile_options(MyApp PRIVATE -O2 -Wall -Wextra)
else()
    target_compile_options(MyApp PRIVATE -g -Wall -Wextra)
endif()
```

**构建命令**：
```bash
# 创建构建目录（out-of-source 构建，避免污染源码）
mkdir build && cd build

# 生成 Makefile
cmake .. -DCMAKE_BUILD_TYPE=Release

# 编译
make -j4 # -j4 表示4线程编译
```

#### （2）其他构建系统
- **Meson**：比 CMake 更简洁，语法更现代，跨平台；
- **Bazel**：Google 开发，支持多语言、增量构建，适合大型项目；
- **Makefile**：适用于小型 Linux 项目，简单直接但跨平台差。

### 3. 测试
测试是保证代码质量的核心，C++ 常用测试框架：

#### （1）Google Test（GTest）：单元测试
GTest 是最流行的 C++ 单元测试框架，支持断言、测试套件、参数化测试等。

**测试示例**：
```cpp
#include <gtest/gtest.h>
#include "calculator.h" // 待测试的头文件

// 测试加法函数
TEST(CalculatorTest, Add) {
    Calculator calc;
    EXPECT_EQ(calc.Add(1, 2), 3); // 预期结果3，不相等时继续执行
    ASSERT_EQ(calc.Add(-1, -1), -2); // 预期结果-2，不相等时终止测试
    EXPECT_GT(calc.Add(5, 3), 7); // 预期结果大于7
}

// 测试减法函数
TEST(CalculatorTest, Subtract) {
    Calculator calc;
    EXPECT_EQ(calc.Subtract(5, 3), 2);
}

int main(int argc, char **argv) {
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

**CMake 集成 GTest**：
```cmake
# 查找 GTest
find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIRS})

# 添加测试可执行文件
add_executable(MyTest test/calculator_test.cpp src/calculator.cpp)

# 链接 GTest
target_link_libraries(MyTest ${GTEST_LIBRARIES} pthread)

# 添加测试目标（make test 运行）
add_test(NAME MyTest COMMAND MyTest)
```

#### （2）Google Mock（GMock）：模拟测试
GMock 用于模拟依赖对象（如数据库、网络接口），让单元测试不依赖外部资源。

#### （3）测试原则
- **单元测试**：测试最小单元（函数/类），隔离依赖；
- **覆盖核心场景**：测试正常路径、异常路径（如参数非法、资源不足）；
- **自动化**：将测试集成到构建流程（如 CI/CD），每次提交自动运行；
- **快速反馈**：单元测试应快速执行（毫秒级），便于频繁运行。

### 4. 其他工程化实践
- **版本控制**：用 Git 管理代码，遵循 Git Flow 或 GitHub Flow 分支模型；
- **代码审查**：通过 Pull Request（GitHub）或 Merge Request（GitLab）进行代码审查，避免低级错误；
- **CI/CD**：用 Jenkins、GitHub Actions 等工具实现持续集成（自动构建、测试）和持续部署（自动发布）；
- **文档**：维护 API 文档（用 Doxygen 自动生成）、架构文档、用户手册；
- **错误处理**：统一错误码或异常类型，便于问题定位；
- **日志**：规范日志输出（级别：DEBUG/INFO/WARN/ERROR/FATAL），包含时间、线程 ID、错误描述。

## 五、实战项目推荐
理论结合实践是提升的关键，推荐以下实战项目（从简单到复杂）：
1. **日志系统**：实现支持多级别、多输出（控制台/文件）、线程安全的日志器（用到单例模式、多线程、文件 IO）；
2. **线程池**：实现支持任务队列、线程复用、超时任务的线程池（用到多线程、同步互斥）；
3. **HTTP 服务器**：基于 TCP 实现简单的 HTTP 服务器，支持静态文件访问、路由分发（用到网络编程、多线程）；
4. **数据库连接池**：实现支持连接复用、超时回收、并发安全的数据库连接池（用到单例模式、线程池、数据库接口）；
5. **简易 STL**：实现 `vector`、`string`、`shared_ptr` 等核心组件（深入理解 STL 底层）。

## 总结
实战提升篇覆盖了 C++ 工程化开发的核心能力，从设计模式（代码设计）、多线程（性能提升）、性能优化（极致效率）到工程化规范（团队协作），形成了完整的技术体系。学习的关键是“理论+实践”：
- 理解设计模式的核心思想，而非死记硬背；
- 多线程编程需注重线程安全，避免死锁和竞态条件；
- 性能优化需先测量后优化，优先解决瓶颈问题；
- 工程化规范是团队协作的基础，养成良好的编码习惯。

通过实战项目将这些知识融会贯通，才能真正从“C++ 初学者”成长为“工程化开发工程师”。
